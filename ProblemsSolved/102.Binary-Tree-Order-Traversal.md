# 102.Binary Tree Order Traversal
## Descriptions
Given a binary tree, return the level order traversal of its nodes' values. 
<br/>(ie, from left to right, level by level).

For example:
Given binary tree [3,9,20,null,null,15,7],
```
    3
   / \
  9  20
    /  \
   15   7
```
return its level order traversal as:
```
[
  [3],
  [9,20],
  [15,7]
]
```
## Solution
本题要求我们按照输入的二叉树头节点输出由二维数组描述的二叉树层次遍历结果。

这是一道经典的算法题，我将使用多种方法实现。

### 1.基于queue的迭代BFS
此方法的主要思想是遍历本行的节点同时存储下一行的节点
#### 算法

- 创建queue数据，将头节点存入其中
- 主循环：从输入的头节点开始遍历二叉树；子循环：遍历每一行的节点
- 子循环开始前，创建临时变量存储当前queue数据的长度（本行节点数），作为子循环的循环次数
- 子循环每处理完一个元素对queue进行一次pop操作，并将节点的val存入一维数组中
- 一个子循环结束后将一维数组与二维数组合并

### 递归

## Code

### 二叉树结构体：

```C++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```
### 基于queue的BFS方法：
语言支持：C++
```C++
vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> ans;
    if(!root) return ans;
    queue<TreeNode*> Q;
    Q.push(root);
    TreeNode* p;
    while(!Q.empty()){
        int width = Q.size();
        vector<int> temp;
        for(int i = 0; i < width; ++i){
            p = Q.front();
            Q.pop();
            temp.push_back(p->val);
            if(p->left) Q.push(p->left);
            if(p->right) Q.push(p->right);
        }
        ans.push_back(temp);
    }
    return ans;
}
```
复杂度分析：
- 时间复杂度：O(n)，每个节点只运算一次
- 空间复杂度：O(n)，保存输出结果的数组包含n个节点的值