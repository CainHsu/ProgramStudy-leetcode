# 构造函数语义学

## 默认构造函数的构造操作

默认构造函数可以自己定义也可以由编译器合成

满足下面所有的条件时, 一个默认构造函数是trivial的:
- 不是由用户提供的, 即是由编译器生成的或者声明为default
- 类没有虚成员函数 
- 类没有虚基类 
- 类没有默认初始化的非静态成员 
- 直接基类有trivial default constructor 
- 非静态类成员有trivial default constructor

编译器合成默认构造函数的前提：
- 用户没有声明构造函数时，编译器会隐式声明一个构造函数

注意：
- 类的默认构造函数只有真正需要时才会被合成, 而不是没有定义构造函数时就会合成
- 对于一个类的所有类成员对象, 如果没有显式初始化, 编译器会对其进行默认初始化. 但是对于内置类型, 例如int, 指针类型等, 不会进行初始化, 这是程序员的工作


根据不同情况此类构造函数的功能分为四类：
- 带有有默认构造函数的类成员
- 基类有默认构造函数
- 有一个虚函数的类
- 继承自虚基类

### 带有有默认构造函数的类成员

若此种类中没有构造函数，则编译器会为此类生成一个构造函数，这个操作仅仅在构造函数真正需要被调用时才发生

为避免在不同编译模块(不同文件)合成多个默认构造函数，解决方式是默认构造、拷贝构造、析构、赋值函数均以inline方式完成。因为inline函数有静态链接，不会被文件以外看到。

#### 此类无构造函数

编译器会调用成员的构造函数对其进行初始化

#### 此类有构造函数

若定义的构造函数中没有调用成员的构造函数部分，编译器会在构造函数中插入代码，按照这些成员在类中声明的顺序来调用构造函数。

即使其中一个成员已经由程序员在构造函数中进行显示的初始化，编译器依然会按照成员声明的顺序插入构造函数。

### 基类有默认构造函数

若此类没有构造函数，则编译器在生成构造函数时会插入调用基类构造函数的代码

若有但没有调用默认构造函数，编译器会将调用构造函数的代码插入最前面

### 有一个虚函数的类
分为两种情况：
- 声明/继承一个虚函数
- 派生自一个继承串链，其中有一个或多个虚拟基类

解决方式：
- 对于静态初始化的对象, vptr由编译器初始化.
- 对于动态初始化的对象, vptr由构造函数初始化. 因此编译器会在所有的构造函数中插入一些代码来完成这个任务.

### 继承自虚基类
采用了虚继承, 同一变 量偏移可能不一样(这是由实现决定的), 简而言之就是编译器不知道成员在指针所指对象的什么位置

因此, 存在虚基类时, 就需要提供某种方法, 使我们能够通过虚基类指针访问虚基类的非虚函数和数据成员

一种方法是在子类中插入一个指向虚基类的指针, 将原始的通过虚基类指针访问那些成员的代码替换为先访问这个指针, 再访问成员的代码

如下所示:
```c++
virtualBasePointer->virtualBaseData; // 原始代码
virtualBasePointer->virtualBaseVptr->virtualBaseData; // 编译器替换后的代码
```

## 复制构造函数的构造操作

有三种情况会调用复制构造函数：
- 对一个对象做显示的初始化操作
```c++
class X x;
class X xx = x;
```
- 对象作为参数传递给函数
- 函数返回一个对象

编译器有两种复制对象的方法：
- bitwise copy: 不调用复制构造函数，使用memcpy等方式
- default memberwise initialization: 对每个成员分别赋值，对于内置类型直接初始化，对于类类型递归调用默认复制构造函数来初始化

编译器会在以下条件中选择bitwise，其他条件中选择memberwise
- 类含有对象成员，且这个成员有复制构造函数(无论是编译器合成的还是自己设计的)
- 类继承自一个基类，且基类中有构造函数(无论。。。)
- 有虚函数时
- 继承虚基类时

对于1和2，既然有拷贝函数，就说明其中存在bitwise无法处理的情况，需要调用复制构造函数；
对于3，由于有虚函数，就需要vptr，而vptr的值不一定等于参数对象的值，比如使用子类对象初始化父类对象；
对于虚基类，父子基类的内存结构可能有区别

## 程序转化语义学

### 显式的初始化操作

```c++
x x0;
x x1(x0);
x x2 = x0;
x x3 = x(x0);
```
转化为：
```c++
x x1;
...
x x3;
x1.x::(x0);
...
x3.x::x(x0);
```

### 参数的初始化
```c++
x x0;
foo(x0);
```
转化为：
```c++
x _temp;
_temp.x::x(x0);
foo(_temp);
```

### 返回值初始化
```c++
x foo(){
    x x0;
    ...
    return x0;
}
```
- 首先，将返回对象改为void，并加入一个额外参数，用于放置被拷贝构造而得的返回值
- 在原return命令后加入拷贝构造函数

函数转化为：
```c++
void foo(x &_res){
    x x0;
    x0.x::x();
    ...
    _res.x::x(x0);
    return;
}
```
调用转化为：
```c++
x x0;
bar(x0);
```

### 在使用者层面做优化
```c++
x bar(const T &y, const T &z){
    x x0;
    ...
    return x0;
}
```
应修改为：
```c++
x bar(const T &y, const T &z){
    return x(y,z);
}
```
此时效率较高：
```c++
void bar(x &_res, const T &y, const T &z){
    _res.x::x(y,z);
    return;
}
```

## 成员初始化列表
应使用成员初始化列表的情况：
- 初始化一个引用时
- 初始化一个常量成员时
- 调用基类的构造函数, 并且这个构造函数有一组参数时
- 调用类成员的构造函数, 并且这个构造函数有一组参数时

```c++
word::word() : _name(0){
    cnt = 0;
}
转化为
word::word(){
    _name.string::string(0);
    cnt = 0;
}
```
当有多个成员进行初始化时，编译器按照类中成员的声明顺序在构造函数中插入代码。

尽量使初始化列表的顺序与声明顺序一致, 最好不要用一个成员来初始化另一个成员. 在编译阶段, 会将初始化列表转化为成员的初始化代码, 并置于构造函数体内的代码之前.

注意一点, 用成员函数的返回值来作为初始化列表的参数语法上是没有问题的, 但是需要保证这个成员函数不依赖于成员的数据对象, 因为很可能这个在调用此函数时还没有初始化其依赖的数据成员, 这就会引起难以发现的错误. 另外, 最好不要将其用于初始化基类成员, 详情见后面的讨论.